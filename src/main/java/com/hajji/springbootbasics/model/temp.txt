package com.hajji.springbootbasics.model;

import jakarta.persistence.*;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name="Users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "UserID")
    private Integer userId;

    @Column(name = "FirstName", nullable = false, length = 100)
    private String firstName;

    @Column(name = "LastName", nullable = false, length = 100)
    private String lastName;

    @Column(name = "Email", nullable = false, unique = true, length = 200)
    private String email;

    @Column(name = "PasswordHash", nullable = false, length = 500)
    private String passwordHash;

    @Column(name = "IsActive")
    private Boolean isActive = true;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    /*--------------Relationships---------------*/


    // Many Users <-> Many Roles (via UserRoleAssignments)
    @ManyToMany
    @JoinTable(
            name = "UserRoleAssignments",
            joinColumns = @JoinColumn(name = "UserID"),
            inverseJoinColumns = @JoinColumn(name = "RoleID")
    )
    private Set<Role> roles = new HashSet<>();


    // One User -> Many FileStorage (uploaded files)
    @OneToMany(mappedBy = "uploadedBy")
    private Set<FileStorage> uploadedFiles = new HashSet<>();

    // One User -> Many ProjectAssignments
    @OneToMany(mappedBy = "user")
    private Set<ProjectAssignment> projectAssignments = new HashSet<>();

    // One User -> Many ProjectDocuments (last modified by)
    @OneToMany(mappedBy = "lastModifiedBy")
    private Set<ProjectDocument> modifiedDocuments = new HashSet<>();

    // One User -> Many DocumentRevisions (modified by)
    @OneToMany(mappedBy = "modifiedBy")
    private Set<DocumentRevision> documentRevisions = new HashSet<>();

}
package com.hajji.springbootbasics.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "StandardTemplates")
public class StandardTemplate {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "TemplateID")
    private Integer templateId;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    /* ---------------- Relationships ---------------- */
    @ManyToOne
    @JoinColumn(name = "SectionID", nullable = false)
    private StandardSection section;

    @ManyToOne
    @JoinColumn(name = "FileID", nullable = false)
    private FileStorage file;

    // Getters & Setters
}
package com.hajji.springbootbasics.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "StandardStatuses")
public class StandardStatus {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "StatusID")
    private Integer statusId;

    @Column(name = "StatusName", nullable = false, unique = true, length = 50)
    private String statusName;

    @Column(name = "Description", length = 200)
    private String description;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    /* ---------------- Relationships ---------------- */
    @OneToMany(mappedBy = "status")
    private Set<Project> projects = new HashSet<>();

    // Getters & Setters
}
package com.hajji.springbootbasics.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "StandardSections")
public class StandardSection {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "SectionID")
    private Integer sectionId;

    @Column(name = "Number", nullable = false, length = 50)
    private String number;

    @Column(name = "Title", nullable = false, length = 200)
    private String title;

    @Column(name = "OrderIndex")
    private Integer orderIndex;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    /* ---------------- Relationships ---------------- */
    @ManyToOne
    @JoinColumn(name = "StandardID", nullable = false)
    private Standard standard;

    @ManyToOne
    @JoinColumn(name = "ParentSectionID")
    private StandardSection parentSection;

    @OneToMany(mappedBy = "parentSection")
    private Set<StandardSection> childSections = new HashSet<>();

    @OneToMany(mappedBy = "section")
    private Set<StandardTemplate> templates = new HashSet<>();

    // Getters & Setters
}
package com.hajji.springbootbasics.model;

import jakarta.persistence.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "Standards")
public class Standard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "StandardID")
    private Integer standardId;

    @Column(name = "Name", nullable = false, length = 200)
    private String name;

    @Column(name = "Version", length = 50)
    private String version;

    @Column(name = "PublishedDate")
    private LocalDate publishedDate;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    /* ---------------- Relationships ---------------- */
    @OneToMany(mappedBy = "standard")
    private Set<StandardSection> sections = new HashSet<>();

    @OneToMany(mappedBy = "standard")
    private Set<Project> projects = new HashSet<>();

    // Getters & Setters
}
package com.hajji.springbootbasics.model;

import jakarta.persistence.*;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;


@Entity
@Table(name = "Roles")
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "RoleID")
    private Integer roleId;

    @Column(name = "RoleName", nullable = false, unique = true, length = 100)
    private String roleName;

    @Column(name = "Description", length = 200)
    private String description;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    // üîπ Relationships

    // Many-to-Many with Users (via UserRoleAssignments)
    @ManyToMany(mappedBy = "roles")
    private Set<User> users = new HashSet<>();

    // Many-to-Many with Permissions (via RolePermissionMappings)
    @ManyToMany
    @JoinTable(
            name = "RolePermissionMappings",
            joinColumns = @JoinColumn(name = "RoleID"),
            inverseJoinColumns = @JoinColumn(name = "PermissionID")
    )
    private Set<Permission> permissions = new HashSet<>();

    // Constructors
    public Role() {}



}
package com.hajji.springbootbasics.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "ProjectDocuments")
public class ProjectDocument {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ProjectDocumentID")
    private Integer projectDocumentId;

    @Column(name = "VersionNumber")
    private Integer versionNumber;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    /* ---------------- Relationships ---------------- */
    @ManyToOne
    @JoinColumn(name = "ProjectID", nullable = false)
    private Project project;

    @ManyToOne
    @JoinColumn(name = "TemplateID", nullable = false)
    private StandardTemplate template;

    @ManyToOne
    @JoinColumn(name = "FileID", nullable = false)
    private FileStorage file;

    @ManyToOne
    @JoinColumn(name = "StatusID", nullable = false)
    private DocumentStatus status;

    @ManyToOne
    @JoinColumn(name = "LastModifiedBy")
    private User lastModifiedBy;

    @OneToMany(mappedBy = "projectDocument")
    private Set<DocumentRevision> revisions = new HashSet<>();

    // Getters & Setters
}
package com.hajji.springbootbasics.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(
        name = "ProjectAssignments",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = {"ProjectID", "UserID"})
        }
)
public class ProjectAssignment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "AssignmentID")
    private Integer assignmentId;

    @Column(name = "AssignedAt")
    private LocalDateTime assignedAt;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    /* ---------------- Relationships ---------------- */
    @ManyToOne
    @JoinColumn(name = "ProjectID", nullable = false)
    private Project project;

    @ManyToOne
    @JoinColumn(name = "UserID", nullable = false)
    private User user;

    // Many-to-Many between ProjectAssignments and Roles
    @ManyToMany
    @JoinTable(
            name = "ProjectRoles",
            joinColumns = @JoinColumn(name = "AssignmentID"),
            inverseJoinColumns = @JoinColumn(name = "RoleID")
    )
    private Set<Role> roles = new HashSet<>();

    // Getters & Setters
}
package com.hajji.springbootbasics.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "Projects")
public class Project {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ProjectID")
    private Integer projectId;

    @Column(name = "StartDate")
    private LocalDateTime startDate;

    @Column(name = "CompletionDate")
    private LocalDateTime completionDate;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    /* ---------------- Relationships ---------------- */
    @ManyToOne
    @JoinColumn(name = "CustomerID", nullable = false)
    private Customer customer;

    @ManyToOne
    @JoinColumn(name = "StandardID", nullable = false)
    private Standard standard;

    @ManyToOne
    @JoinColumn(name = "StatusID", nullable = false)
    private StandardStatus status;

    @OneToMany(mappedBy = "project")
    private Set<ProjectDocument> projectDocuments = new HashSet<>();

    @OneToMany(mappedBy = "project")
    private Set<ProjectAssignment> assignments = new HashSet<>();

    // Getters & Setters
}
package com.hajji.springbootbasics.model;


import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "Permissions")
public class Permission {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "PermissionID")
    private Integer permissionId;

    @Column(name = "PermissionName", nullable = false, unique = true, length = 100)
    private String permissionName;

    @Column(name = "Description", length = 200)
    private String description;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    /* ------------ Relationships ------------ */

    // Many-to-Many with Roles (via RolePermissionMappings)
    @ManyToMany(mappedBy = "permissions")
    private Set<Role> roles = new HashSet<>();

    /* ------------ Constructors ------------ */

    public Permission() {}

    /* ------------ Getters & Setters ------------ */

    public Integer getPermissionId() {
        return permissionId;
    }

    public void setPermissionId(Integer permissionId) {
        this.permissionId = permissionId;
    }

    public String getPermissionName() {
        return permissionName;
    }

    public void setPermissionName(String permissionName) {
        this.permissionName = permissionName;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getModifiedAt() {
        return modifiedAt;
    }

    public void setModifiedAt(LocalDateTime modifiedAt) {
        this.modifiedAt = modifiedAt;
    }

    public Set<Role> getRoles() {
        return roles;
    }

    public void setRoles(Set<Role> roles) {
        this.roles = roles;
    }
}package com.hajji.springbootbasics.model;


 import jakarta.persistence.*;

 import java.time.LocalDateTime;
 import java.util.HashSet;
 import java.util.Set;

 @Entity
 @Table(name = "FileStorage")
 public class FileStorage {
     @Id
     @GeneratedValue(strategy = GenerationType.IDENTITY)
     @Column(name="FileID")
     private Integer fileId;


     @Column(name = "FileName", nullable = false, length = 200)
     private String fileName;

     @Column(name = "FilePath", nullable = false, length = 500)
     private String filePath;

     @Column(name = "FileSize")
     private Long fileSize;

     @Column(name = "UploadedAt")
     private LocalDateTime uploadedAt;

     /* ---------------- Relationships ---------------- */
     @ManyToOne
     @JoinColumn(name = "UploadedBy", nullable = false)
     private User uploadedBy;


     @OneToMany(mappedBy = "file")
     private Set<StandardTemplate> standardTemplates = new HashSet<>();


     // One FileStorage may be referenced in many project documents
     @OneToMany(mappedBy = "file")
     private Set<ProjectDocument> projectDocuments = new HashSet<>();

     // One FileStorage may be referenced in many revisions
     @OneToMany(mappedBy = "file")
     private Set<DocumentRevision> documentRevisions = new HashSet<>();


 }
package com.hajji.springbootbasics.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "DocumentStatuses")
public class DocumentStatus {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "StatusID")
    private Integer statusId;

    @Column(name = "StatusName", nullable = false, unique = true, length = 50)
    private String statusName;

    @Column(name = "Description", length = 200)
    private String description;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    /* ---------------- Relationships ---------------- */
    @OneToMany(mappedBy = "status")
    private Set<ProjectDocument> projectDocuments = new HashSet<>();

    // Getters & Setters
}
package com.hajji.springbootbasics.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "DocumentRevisions")
public class DocumentRevision {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "RevisionID")
    private Integer revisionId;

    @Column(name = "VersionNumber", nullable = false)
    private Integer versionNumber;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    @Column(name = "ChangeNote", length = 500)
    private String changeNote;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    /* ---------------- Relationships ---------------- */
    @ManyToOne
    @JoinColumn(name = "ProjectDocumentID", nullable = false)
    private ProjectDocument projectDocument;

    @ManyToOne
    @JoinColumn(name = "FileID", nullable = false)
    private FileStorage file;

    @ManyToOne
    @JoinColumn(name = "ModifiedBy", nullable = false)
    private User modifiedBy;

    // Getters & Setters
}
package com.hajji.springbootbasics.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "Customers")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "CustomerID")
    private Integer customerId;

    @Column(name = "Name", nullable = false, length = 200)
    private String name;

    @Column(name = "Email", unique = true, length = 200)
    private String email;

    @Column(name = "Phone", length = 50)
    private String phone;

    @Column(name = "CreatedAt")
    private LocalDateTime createdAt;

    @Column(name = "ModifiedAt")
    private LocalDateTime modifiedAt;

    /* ---------------- Relationships ---------------- */
    @OneToMany(mappedBy = "customer")
    private Set<Project> projects = new HashSet<>();

    // Getters & Setters
}
hello take a look at this first CREATE DATABASE ISOManagementDB;
GO

USE ISOManagementDB;
GO



CREATE TABLE [Users] (
  [UserID] INT PRIMARY KEY IDENTITY(1, 1),
  [FirstName] NVARCHAR(100) NOT NULL,
  [LastName] NVARCHAR(100) NOT NULL,
  [Email] NVARCHAR(200) UNIQUE NOT NULL,
  [PasswordHash] NVARCHAR(500) NOT NULL,
  [IsActive] BIT DEFAULT (1),
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
)
GO


CREATE TABLE [Roles] (
  [RoleID] INT PRIMARY KEY IDENTITY(1, 1),
  [RoleName] NVARCHAR(100) UNIQUE NOT NULL,
  [Description] NVARCHAR(200),
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
)
GO

CREATE TABLE [UserRoleAssignments] (
  [UserID] INT NOT NULL,
  [RoleID] INT NOT NULL,
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE()),
  PRIMARY KEY ([UserID], [RoleID])
)
GO

CREATE TABLE [Permissions] (
  [PermissionID] INT PRIMARY KEY IDENTITY(1, 1),
  [PermissionName] NVARCHAR(100) UNIQUE NOT NULL,
  [Description] NVARCHAR(200),
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
)
GO

CREATE TABLE [RolePermissionMappings] (
  [RoleID] INT NOT NULL,
  [PermissionID] INT NOT NULL,
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE()),
  PRIMARY KEY ([RoleID], [PermissionID])
)
GO

CREATE TABLE [Customers] (
  [CustomerID] INT PRIMARY KEY IDENTITY(1, 1),
  [Name] NVARCHAR(200) NOT NULL,
  [Email] NVARCHAR(200) UNIQUE,
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
)
GO

CREATE TABLE [Standards] (
  [StandardID] INT PRIMARY KEY IDENTITY(1, 1),
  [Name] NVARCHAR(200) NOT NULL,
  [Version] NVARCHAR(50),
  [PublishedDate] DATE,
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
)
GO

CREATE TABLE [StandardSections] (
  [SectionID] INT PRIMARY KEY IDENTITY(1, 1),
  [StandardID] INT NOT NULL,
  [ParentSectionID] INT,
  [Number] NVARCHAR(50) NOT NULL,
  [Title] NVARCHAR(200) NOT NULL,
  [OrderIndex] INT DEFAULT (0),
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
)
GO

CREATE TABLE [FileStorage] (
  [FileID] INT PRIMARY KEY IDENTITY(1, 1),
  [FileName] NVARCHAR(200) NOT NULL,
  [FilePath] NVARCHAR(500) NOT NULL,
  [FileSize] BIGINT,
  [UploadedBy] INT NOT NULL,
  [UploadedAt] DATETIME DEFAULT (GETDATE())
)
GO

CREATE TABLE [StandardTemplates] (
  [TemplateID] INT PRIMARY KEY IDENTITY(1, 1),
  [SectionID] INT NOT NULL,
  [FileID] INT NOT NULL,
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
)
GO

CREATE TABLE [ProjectDocuments] (
  [ProjectDocumentID] INT PRIMARY KEY IDENTITY(1, 1),
  [ProjectID] INT NOT NULL,
  [TemplateID] INT NOT NULL,
  [FileID] INT NOT NULL,
  [StatusID] INT NOT NULL,
  [VersionNumber] INT DEFAULT (1),
  [LastModifiedBy] INT,
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
)
GO

CREATE TABLE [DocumentRevisions] (
  [RevisionID] INT PRIMARY KEY IDENTITY(1, 1),
  [ProjectDocumentID] INT NOT NULL,
  [FileID] INT NOT NULL,
  [VersionNumber] INT NOT NULL,
  [ModifiedBy] INT NOT NULL,
  [ModifiedAt] DATETIME DEFAULT (GETDATE()),
  [ChangeNote] NVARCHAR(500),
  [CreatedAt] DATETIME DEFAULT (GETDATE())
)
GO

CREATE TABLE [StandardStatuses] (
  [StatusID] INT PRIMARY KEY IDENTITY(1, 1),
  [StatusName] NVARCHAR(50) UNIQUE NOT NULL,
  [Description] NVARCHAR(200),
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
)
GO

CREATE TABLE [Projects] (
  [ProjectID] INT PRIMARY KEY IDENTITY(1, 1),
  [CustomerID] INT NOT NULL,
  [StandardID] INT NOT NULL,
  [StatusID] INT NOT NULL,
  [StartDate] DATETIME,
  [CompletionDate] DATETIME,
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
)
GO

CREATE TABLE [ProjectAssignments] (
  [AssignmentID] INT PRIMARY KEY IDENTITY(1, 1),
  [ProjectID] INT NOT NULL,
  [UserID] INT NOT NULL,
  [AssignedAt] DATETIME DEFAULT (GETDATE()),
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
  -- üîí Ensure each user can only be assigned ONCE per project
    CONSTRAINT UQ_Project_User UNIQUE (ProjectID, UserID)
)
GO

CREATE TABLE [ProjectRoles] (
  [AssignmentID] INT NOT NULL,
  [RoleID] INT NOT NULL,
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE()),
  PRIMARY KEY ([AssignmentID], [RoleID])
)
GO

CREATE TABLE [DocumentStatuses] (
  [StatusID] INT PRIMARY KEY IDENTITY(1, 1),
  [StatusName] NVARCHAR(50) UNIQUE NOT NULL,
  [Description] NVARCHAR(200),
  [CreatedAt] DATETIME DEFAULT (GETDATE()),
  [ModifiedAt] DATETIME DEFAULT (GETDATE())
)
GO

ALTER TABLE [UserRoleAssignments] ADD FOREIGN KEY ([UserID]) REFERENCES [Users] ([UserID])
GO

ALTER TABLE [UserRoleAssignments] ADD FOREIGN KEY ([RoleID]) REFERENCES [Roles] ([RoleID])
GO

ALTER TABLE [RolePermissionMappings] ADD FOREIGN KEY ([RoleID]) REFERENCES [Roles] ([RoleID])
GO

ALTER TABLE [RolePermissionMappings] ADD FOREIGN KEY ([PermissionID]) REFERENCES [Permissions] ([PermissionID])
GO

ALTER TABLE [StandardSections] ADD FOREIGN KEY ([StandardID]) REFERENCES [Standards] ([StandardID])
GO

ALTER TABLE [StandardSections] ADD FOREIGN KEY ([ParentSectionID]) REFERENCES [StandardSections] ([SectionID])
GO

ALTER TABLE [FileStorage] ADD FOREIGN KEY ([UploadedBy]) REFERENCES [Users] ([UserID])
GO

ALTER TABLE [StandardTemplates] ADD FOREIGN KEY ([SectionID]) REFERENCES [StandardSections] ([SectionID])
GO

ALTER TABLE [StandardTemplates] ADD FOREIGN KEY ([FileID]) REFERENCES [FileStorage] ([FileID])
GO

ALTER TABLE [ProjectDocuments] ADD FOREIGN KEY ([ProjectID]) REFERENCES [Projects] ([ProjectID])
GO

ALTER TABLE [ProjectDocuments] ADD FOREIGN KEY ([TemplateID]) REFERENCES [StandardTemplates] ([TemplateID])
GO

ALTER TABLE [ProjectDocuments] ADD FOREIGN KEY ([FileID]) REFERENCES [FileStorage] ([FileID])
GO

ALTER TABLE [ProjectDocuments] ADD FOREIGN KEY ([StatusID]) REFERENCES [DocumentStatuses] ([StatusID])
GO

ALTER TABLE [ProjectDocuments] ADD FOREIGN KEY ([LastModifiedBy]) REFERENCES [Users] ([UserID])
GO

ALTER TABLE [DocumentRevisions] ADD FOREIGN KEY ([ProjectDocumentID]) REFERENCES [ProjectDocuments] ([ProjectDocumentID])
GO

ALTER TABLE [DocumentRevisions] ADD FOREIGN KEY ([FileID]) REFERENCES [FileStorage] ([FileID])
GO

ALTER TABLE [DocumentRevisions] ADD FOREIGN KEY ([ModifiedBy]) REFERENCES [Users] ([UserID])
GO

ALTER TABLE [Projects] ADD FOREIGN KEY ([CustomerID]) REFERENCES [Customers] ([CustomerID])
GO

ALTER TABLE [Projects] ADD FOREIGN KEY ([StandardID]) REFERENCES [Standards] ([StandardID])
GO

ALTER TABLE [Projects] ADD FOREIGN KEY ([StatusID]) REFERENCES [StandardStatuses] ([StatusID])
GO

ALTER TABLE [ProjectAssignments] ADD FOREIGN KEY ([ProjectID]) REFERENCES [Projects] ([ProjectID])
GO

ALTER TABLE [ProjectAssignments] ADD FOREIGN KEY ([UserID]) REFERENCES [Users] ([UserID])
GO

ALTER TABLE [ProjectRoles] ADD FOREIGN KEY ([AssignmentID]) REFERENCES [ProjectAssignments] ([AssignmentID])
GO

ALTER TABLE [ProjectRoles] ADD FOREIGN KEY ([RoleID]) REFERENCES [Roles] ([RoleID])
GO

package com.hajji.springbootbasics.controller;

import com.hajji.springbootbasics.dto.file.FileStorageResponseDTO;
import com.hajji.springbootbasics.dto.response.ApiResponse;
import com.hajji.springbootbasics.dto.standard.*;
import com.hajji.springbootbasics.service.StandardService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@RestController
@RequestMapping("/api/standard/")
public class StandardController {

    private final StandardService standardService;

    public StandardController(StandardService standardService) {
        this.standardService = standardService;
    }

    /* ---------------- STANDARD CRUD ---------------- */

    @GetMapping("/all")
    public ResponseEntity<ApiResponse<List<StandardResponseDTO>>> getAllStandards() {
        List<StandardResponseDTO> standards = standardService.getAllStandards();

        ApiResponse<List<StandardResponseDTO>> response = new ApiResponse<>(
                HttpStatus.OK.value(),
                "Standards fetched successfully",
                standards
        );

        return ResponseEntity.ok(response);
    }

    @PostMapping("create")
    public ResponseEntity<ApiResponse<StandardResponseDTO>> createStandard(
            @Valid @RequestBody CreateStandardRequestDTO requestDTO) {

        StandardResponseDTO standard = standardService.createStandard(requestDTO);

        ApiResponse<StandardResponseDTO> response = new ApiResponse<>(
                HttpStatus.OK.value(),
                "Standard created successfully",
                standard
        );

        return ResponseEntity.ok(response);
    }

    @DeleteMapping("delete/{standardId}")
    public ResponseEntity<ApiResponse<String>> deleteStandard(@PathVariable Integer standardId) {
        standardService.deleteStandard(standardId);

        ApiResponse<String> response = new ApiResponse<>(
                HttpStatus.OK.value(),
                "Standard deleted successfully",
                "Standard ID: " + standardId
        );

        return ResponseEntity.ok(response);
    }

    /* ---------------- SECTION CREATE ---------------- */

    @PostMapping("{standardId}/sections/create")
    public ResponseEntity<ApiResponse<StandardSectionResponseDTO>> createSection(
            @PathVariable Integer standardId,
            @Valid @RequestBody CreateStandardSectionRequestDTO dto) {

        dto.setStandardId(standardId); // enforce standard from URL
        StandardSectionResponseDTO section = standardService.createSection(dto);

        ApiResponse<StandardSectionResponseDTO> response = new ApiResponse<>(
                HttpStatus.OK.value(),
                "Standard section created successfully",
                section
        );

        return ResponseEntity.ok(response);
    }



    @GetMapping("{standardId}/treeView")
    public ResponseEntity<ApiResponse<StandardSectionTreeDTO>> getStandardSectionTree(
            @PathVariable Integer standardId) {

        StandardSectionTreeDTO tree = standardService.getStandardSectionTree(standardId);

        ApiResponse<StandardSectionTreeDTO> response = new ApiResponse<>(
                HttpStatus.OK.value(),
                "Standard Tree Fetched successfully",
                tree
        );

        return ResponseEntity.ok(response);
    }



    /*--------------File upload here --------------------*/
    @PostMapping("{standardId}/sections/{sectionId}/upload")
    public ResponseEntity<ApiResponse<FileStorageResponseDTO>> uploadFileToSection(
            @PathVariable Integer standardId,
            @PathVariable Integer sectionId,
            @RequestParam("file") MultipartFile file,
            @RequestParam("userId") Integer userId) {

        // Delegate to service
        FileStorageResponseDTO uploaded = standardService.uploadFileToSection(file , userId, sectionId);

        ApiResponse<FileStorageResponseDTO> response = new ApiResponse<>(
                HttpStatus.OK.value(),
                "File uploaded successfully",
                uploaded
        );

        return ResponseEntity.ok(response);
    }



    @DeleteMapping("{standardId}/sections/{sectionId}/files/{fileId}")
    public ResponseEntity<ApiResponse<String>> deleteFileFromSection(
            @PathVariable Integer standardId,
            @PathVariable Integer sectionId,
            @PathVariable Integer fileId
    ) {
        standardService.removeFileFromSection(fileId, sectionId);

        ApiResponse<String> response = new ApiResponse<>(
                HttpStatus.OK.value(),
                "File removed successfully",
                "File ID: " + fileId + " from Section ID: " + sectionId
        );

        return ResponseEntity.ok(response);
    }



}
package com.hajji.springbootbasics.service;

import com.hajji.springbootbasics.dto.file.FileStorageResponseDTO;
import com.hajji.springbootbasics.dto.standard.*;
import com.hajji.springbootbasics.exceptions.common.ResourceNotFoundException;
import com.hajji.springbootbasics.exceptions.fileStorage.InvalidFileTypeException;
import com.hajji.springbootbasics.mapper.StandardMapper;
import com.hajji.springbootbasics.mapper.StandardSectionMapper;
import com.hajji.springbootbasics.model.*;
import com.hajji.springbootbasics.repository.StandardRepository;
import com.hajji.springbootbasics.repository.StandardSectionRepository;
import com.hajji.springbootbasics.repository.StandardTemplateRepository;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class StandardService {

    private final StandardRepository standardRepository;
    private final StandardSectionRepository sectionRepository;
    private UserService userService;
    private FileStorageService fileStorageService;
    private StandardTemplateRepository standardTemplateRepository;
    public StandardService(StandardRepository standardRepository,
                           StandardSectionRepository sectionRepository,
                           UserService userService,
                           FileStorageService fileStorageService,
                           StandardTemplateRepository standardTemplateRepository) {
        this.standardRepository = standardRepository;
        this.sectionRepository = sectionRepository;
        this.userService = userService;
        this.fileStorageService = fileStorageService;
        this.standardTemplateRepository = standardTemplateRepository;
    }

    /* ---------------- STANDARD CRUD ---------------- */

    @Transactional
    public StandardResponseDTO createStandard(CreateStandardRequestDTO dto) {
        if (standardRepository.existsByNameAndVersion(dto.getName(), dto.getVersion())) {
            throw new IllegalStateException(
                    "Standard with name '" + dto.getName() + "' and version '" + dto.getVersion() + "' already exists"
            );
        }

        Standard standard = StandardMapper.toEntity(dto);
        standard = standardRepository.save(standard);

        return StandardMapper.toDTO(standard);
    }

    @Transactional
    public List<StandardResponseDTO> getAllStandards() {
        return standardRepository.findAll()
                .stream()
                .map(StandardMapper::toDTO)
                .toList();
    }

    @Transactional
    public StandardResponseDTO getStandardById(Integer id) {
        Standard standard = standardRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Standard not found with ID: " + id));

        return StandardMapper.toDTO(standard);
    }

    @Transactional
    public void deleteStandard(Integer id) {
        Standard standard = standardRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Standard not found with ID: " + id));

        standardRepository.delete(standard);
    }

    /* ---------------- SECTION CREATE ---------------- */
    @Transactional
    public StandardSectionResponseDTO createSection(CreateStandardSectionRequestDTO dto) {
        Standard standard = standardRepository.findById(dto.getStandardId())
                .orElseThrow(() -> new ResourceNotFoundException("Standard not found with ID: " + dto.getStandardId()));

        StandardSection section = new StandardSection();
        section.setNumber(dto.getNumber());
        section.setTitle(dto.getTitle());
        section.setOrderIndex(dto.getOrderIndex());
        section.setStandard(standard);
        section.setCreatedAt(LocalDateTime.now());
        section.setModifiedAt(LocalDateTime.now());

        if (dto.getParentSectionId() != null) {
            StandardSection parent = sectionRepository.findById(dto.getParentSectionId())
                    .orElseThrow(() -> new ResourceNotFoundException("Parent section not found with ID: " + dto.getParentSectionId()));
            section.setParentSection(parent);
        }

        section = sectionRepository.save(section);
        return StandardSectionMapper.toDTO(section);
    }

    @Transactional
    public StandardSectionTreeDTO getStandardSectionTree(Integer standardId) {
        // 1. Fetch the standard
        Standard standard = standardRepository.findById(standardId)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "Standard not found with ID: " + standardId
                ));

        // 2. Fetch its root sections (those without parent)
        List<StandardSection> rootSections = standard.getSections().stream()
                .filter(section -> section.getParentSection() == null)
                .toList();

        // 3. Build the tree recursively
        List<SectionNodeDTO> rootSectionDTOs = rootSections.stream()
                .map(this::mapSectionToTreeNode)
                .toList();

        // 4. Return final tree
        StandardSectionTreeDTO dto = new StandardSectionTreeDTO();
        dto.setId(standard.getStandardId());   // careful: use the correct getter from your entity
        dto.setTitle(standard.getName());
        dto.setVersion(standard.getVersion());
        dto.setSections(rootSectionDTOs);

        return dto;
    }

    /**
     * Recursively maps a StandardSection into  SectionNodeDTO
     */
    private SectionNodeDTO mapSectionToTreeNode(StandardSection section) {
        // Map children recursively
        List<SectionNodeDTO> childNodes = section.getChildSections().stream()
                .map(this::mapSectionToTreeNode)
                .toList();

        // Build and return node
        SectionNodeDTO node = new SectionNodeDTO(
                section.getSectionId(),
                section.getNumber(),
                section.getTitle(),
                section.getOrderIndex(),
                childNodes
        );
        return node;
    }



    private void linkFileToSection(Integer fileId, Integer sectionId) {
        FileStorage file = fileStorageService.getFileById(fileId); // optional: fetch via service
        StandardSection section = sectionRepository.findById(sectionId)
                .orElseThrow(() -> new ResourceNotFoundException("Section not found"));

        StandardTemplate template = new StandardTemplate();
        template.setFile(file);
        template.setSection(section);
        standardTemplateRepository.save(template);
    }






    @Transactional
    public FileStorageResponseDTO uploadFileToSection(MultipartFile file, Integer userId, Integer sectionId) {

        // 1. Fetch section & standard (domain validation)
        StandardSection section = sectionRepository.findById(sectionId)
                .orElseThrow(() -> new ResourceNotFoundException("Section not found with ID: " + sectionId));

        // 2. Delegate the file saving to FileStorageService
        FileStorageResponseDTO fileDTO = fileStorageService.uploadFile(file, userId);

        // 3. Link file to section (creates StandardTemplate)
        linkFileToSection(fileDTO.getFileId(), sectionId);

        return fileDTO;
    }




    @Transactional
    public void removeFileFromSection(Integer fileId, Integer sectionId) {

        // 0Ô∏è‚É£ Check if file exists
        fileStorageService.getFileById(fileId); // throws exception if file not found

        // 1Ô∏è‚É£ Remove link in StandardTemplate table
        StandardTemplate template = standardTemplateRepository
                .findByFile_FileIdAndSection_SectionId(fileId, sectionId)
                .orElseThrow(() -> new ResourceNotFoundException("File not linked to section"));

        standardTemplateRepository.delete(template);

        // 2Ô∏è‚É£ Delete file metadata via FileStorageService
        fileStorageService.deleteFile(fileId);
    }







}
